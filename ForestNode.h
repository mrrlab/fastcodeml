#ifndef FORESTNODE_H
#define FORESTNODE_H

#include <vector>
#include <iostream>
#include <climits>
#include <cstring>
#include "MatrixSize.h"


/// One node of the forest generated by Forest.
///
///     @author Mario Valle - Swiss National Supercomputing Centre (CSCS)
///     @date 2011-02-23 (initial version)
///     @version 1.0
///
///
struct ForestNode
{
	std::vector<ForestNode *>	mChildrenList;		///< List of the node children
	std::string					mNodeName;			///< Node label
	//std::string				mNodeMark;			///< Node type or empty if the '#' part is not present
	double						mBranchLength;		///< Length of the branch leading to this node as read from the file (not valid for the root)
	ForestNode*					mParent;			///< Pointer to the node parent (null for the root)
	std::vector<int>			mCodons;			///< List of codon idx for the subtree rooted at this node
	std::vector<bool>			mChildSameTree;		///< True if the corresponding child in mChildrenList is in the same tree
	double						mProb[N*Nt];		///< Codons probability array (called g in the pseudocode) (can be computed by concurrent tree traversals)
	unsigned int				mInternalNodeId;	///< Internal node identifier to mark a branch as foreground. UINT_MAX means not an internal node
	unsigned int				mNodeId;			///< An unique index to access the branch length array
	unsigned int				mOwnTree;			///< A per tree identifier used to print the resulting forest
	std::vector<double *>		mOtherTreeProb;		///< Pointers to other tree precomputed mProb, zero if not used, or local array if used from other tree

	/// Constructor
	///
	ForestNode()
	{
		mParent = 0;
	}

	/// Destructor
	///
	~ForestNode()
	{
		// Delete children if in the same tree. Delete partial Prob arrays if not pointer to other tree partial Prob array
		std::vector<ForestNode*>::iterator irn;
		unsigned int i;
		for(irn=mChildrenList.begin(), i=0; irn != mChildrenList.end(); ++irn, ++i)
		{
			if(mChildSameTree[i])
			{
				delete (*irn);

				delete [] mOtherTreeProb[i];
			}
		}

		// Clean all arrays
		mChildrenList.clear();
		mCodons.clear();
		mChildSameTree.clear();
		mOtherTreeProb.clear();
	}

	/// Copy constructor and assignment
	///
	/// @param[in] aNode Node that has to be assigned to the current node
	///
	ForestNode(const ForestNode& aNode)
	{
		mChildrenList  = aNode.mChildrenList;
		mNodeName      = aNode.mNodeName;
		mBranchLength  = aNode.mBranchLength;
		mParent        = aNode.mParent;
		mCodons        = aNode.mCodons;
		mChildSameTree = aNode.mChildSameTree;
		memcpy(mProb, aNode.mProb, N*Nt*sizeof(double));
		mInternalNodeId = aNode.mInternalNodeId;
		mNodeId         = aNode.mNodeId;
		mOwnTree        = aNode.mOwnTree;
		mOtherTreeProb  = aNode.mOtherTreeProb;
	}

	/// Assignment operator
	///
	/// @param[in] aNode Node that has to be assigned to the current node
	///
	/// @return The node itself
	///
	ForestNode& operator=(const ForestNode& aNode)
	{
		// Make sure not same object
		if(this != &aNode)
		{
			mChildrenList  = aNode.mChildrenList;
			mNodeName      = aNode.mNodeName;
			mBranchLength  = aNode.mBranchLength;
			mParent        = aNode.mParent;
			mCodons        = aNode.mCodons;
			mChildSameTree = aNode.mChildSameTree;
			memcpy(mProb, aNode.mProb, N*Nt*sizeof(double));
			mInternalNodeId = aNode.mInternalNodeId;
			mNodeId         = aNode.mNodeId;
			mOwnTree        = aNode.mOwnTree;
			mOtherTreeProb  = aNode.mOtherTreeProb;
		}

		// Return ref for multiple assignment
		return *this;
	}

	/// Print from this node down
	///
	/// @param[in] aOut Output stream
	/// @param[in] aIndent Initial number of indent spaces.
	/// @param[in] aIncrement The indent amount is incremented by this value at each level
	///
	void print(std::ostream& aOut=std::cerr, unsigned int aIndent=0, unsigned int aIncrement=3) const
	{
		unsigned int i;

		// Indent
		for(i=0; i < aIndent; ++i) aOut << ' ';

		// Print the name
		aOut << '<' << mNodeName << "> ";
	
		// Print the ID
		if(mInternalNodeId != UINT_MAX) aOut << '(' << mInternalNodeId << '|' << mNodeId << ") ";
		else                            aOut << '('                    << '|' << mNodeId << ") ";

		// Print the indexes of the codons accumulated till this node
		std::vector<int>::const_iterator ig;
		for(ig=mCodons.begin(); ig != mCodons.end(); ++ig) aOut << *ig << ' ';
		aOut << std::endl;

		// Print the subtree
		std::vector<ForestNode*>::const_iterator irn;
		for(irn=mChildrenList.begin(), i=0; irn != mChildrenList.end(); ++irn, ++i)
		{
			// If the subtree is on the same tree, then print it, otherwise print only the subtree root node name.
			if(mChildSameTree[i])
			{
				(*irn)->print(aOut, aIndent+aIncrement, aIncrement);
			}
			else
			{
				for(i=0; i < aIndent+aIncrement; ++i) aOut << ' ';
				aOut << '[' << (*irn)->mNodeName << ']' << std::endl;
			}
		}
	}

	/// Create a list of pointers to leaves.
	///
	/// @param[out] aLeafsList Pointers to leaves are pushed to this vector
	///
	void pushLeaf(std::vector<ForestNode*>& aLeafsList) 
	{
		if(mChildrenList.empty()) aLeafsList.push_back(this);
		std::vector<ForestNode*>::const_iterator irn;
		for(irn=mChildrenList.begin(); irn != mChildrenList.end(); ++irn) (*irn)->pushLeaf(aLeafsList);
	}

	/// Fills the mCodons list with the union of the lists of the children
	///
	void gatherCodons(void)
	{
		std::vector<ForestNode*>::const_iterator irn;
		for(irn=mChildrenList.begin(); irn != mChildrenList.end(); ++irn)
		{
			(*irn)->gatherCodons();
			mCodons.insert(mCodons.end(), (*irn)->mCodons.begin(), (*irn)->mCodons.end());
		}
	}

	/// Count the total branches in the forest
	///
	/// @param[in] aAggressiveStrategy If true use the aggressive simplification strategy
	///
	unsigned int countBranches(bool aAggressiveStrategy=false) const
	{
		unsigned int cnt = 0;
		unsigned int i;

		// Visit the subtrees
		std::vector<ForestNode*>::const_iterator irn;
		for(irn=mChildrenList.begin(), i=0; irn != mChildrenList.end(); ++irn, ++i)
		{
			// If the subtree is on the same tree, then print it, otherwise print only the subtree root node name.
			if(mChildSameTree[i])
			{
				cnt += (*irn)->countBranches(aAggressiveStrategy)+1;
			}
			else if(!aAggressiveStrategy)
			{
				cnt += 1;
			}
		}
	
		return cnt;
	}
};

#endif

